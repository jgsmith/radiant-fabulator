class Fabulator::XSM::ExpressionParser
  # based on XSM expression grammer from 
  #    http://cpansearch.perl.org/src/JSMITH/Gestinanna-0.02/parser.PL

  # instead of compiling ruby code, we'll instantiate objects to handle the
  # run-time performance

  start statements

rule
  statements: statement { result = Fabulator::XSM::StatementList.new; result.add_statement(val[0]) }
    | statements SEMI statement { result = val[0]; result.add_statement(val[2]) }

  statement: 
    | expr
    | let_expr

  expr: or_expr
    | range_expr
    | if_expr
    | for_expr
    | quant_expr

  let_expr: LET DOLLAR_QNAME COLON_EQUAL expr { result = Fabulator::XSM::LetExpr.new(val[1], val[3]) }
  

  if_expr: IF LP expr RP THEN expr ELSE expr { result = Fabulator::XSM::IfExpr.new(val[2], val[5], val[7]) }
    | IF LP expr RP THEN expr { result = Fabulator::XSM::IfExpr.new(val[2], val[5], nil) }

  for_expr: FOR for_vars RETURN expr { result = Fabulator::XSM::ForExpr.new(val[1], val[3]) }

  for_vars: for_var { result = [ val[0] ] }
    | for_vars COMMA for_var { result = val[0] + [ val[2] ] }

  for_var: DOLLAR_QNAME IN expr { result = Fabulator::XSM::ForVar.new(val[0], val[2]) }

  quant_expr: SOME for_vars SATISFIES expr { result = Fabulator::XSM::SomeExpr.new(val[1], val[3]) }
    | EVERY for_vars SATISFIES expr { result = Fabulator::XSM::EveryExpr.new(val[1], val[3]) }

  or_expr: and_expr
    | or_expr OR and_expr { result = Fabulator::XSM::OrExpr.new(val[0], val[2]) }

  and_expr: equality_expr
    | and_expr AND equality_expr { result = Fabulator::XSM::AndExpr.new(val[0], val[2]) }
    | and_expr EXCEPT equality_expr { result = Fabulator::XSM::ExceptExpr.new(val[0], val[2]) }

  equality_expr: relational_expr
    | equality_expr EQ relational_expr { result = Fabulator::XSM::EqExpr.new(val[0], val[2]) }
    | equality_expr NEQ relational_expr { result = Fabulator::XSM::NeqExpr.new(val[0], val[2]) }

  relational_expr: additive_expr
    | relational_expr LT additive_expr { result = Fabulator::XSM::LtExpr.new(val[0], val[2]) }
    | relational_expr GT additive_expr { result = Fabulator::XSM::LtExpr.new(val[2], val[0]) }
    | relational_expr LTE additive_expr { result = Fabulator::XSM::LteExpr.new(val[0], val[2]) }
    | relational_expr GTE additive_expr { result = Fabulator::XSM::LteExpr.new(val[2], val[0]) }

  range_expr: additive_expr DOT_DOT additive_expr { result = Fabulator::XSM::RangeExpr.new(val[0], val[2]) }
    | additive_expr TO additive_expr { result = Fabulator::XSM::RangeExpr.new(val[0], val[2]) }

  additive_expr: multiplicative_expr
    | additive_expr PLUS multiplicative_expr { result = Fabulator::XSM::AddExpr.new(val[0], val[2]) }
    | additive_expr MINUS multiplicative_expr { result = Fabulator::XSM::SubExpr.new(val[0], val[2]) }

  multiplicative_expr: unary_expr
    | multiplicative_expr STAR unary_expr { result = Fabulator::XSM::MpyExpr.new(val[0], val[2]) }
    | multiplicative_expr DIV unary_expr { result = Fabulator::XSM::DivExpr.new(val[0], val[2]) }
    | multiplicative_expr MOD unary_expr { result = Fabulator::XSM::ModExpr.new(val[0], val[2]) }

  unary_expr: union_expr
    | MINUS unary_expr { result = Fabulator::XSM::NegExpr.new(val[1]) }

  union_expr: path_expr
    | union_expr_x { result = Fabulator::XSM::UnionExpr.new(val[0]) }

  union_expr_x: path_expr PIPE path_expr { result = [ val[0], val[2] ] }
    | union_expr_x PIPE path_expr { result = val[0] + [ val[2] ] }

  path_expr: location_path { result = Fabulator::XSM::PathExpr.new(nil, [], val[0]) }
    | primary_expr predicates segment { result = Fabulator::XSM::PathExpr.new(val[0], val[1], val[2]) }

  segment:
    | SLASH relative_location_path { result = val[1] }
    | SLASH_SLASH relative_location_path { result = [ Fabulator::XSM::AxisDescendentOrSelf.new ] + val[1] }

  location_path: relative_location_path 
    | absolute_location_path

  # / => local data root
  # // => local data descendent or self

  absolute_location_path: SLASH { result = Fabulator::XSM::RootContext.new }
    | SLASH relative_location_path { result = Fabulator::XSM::PathExpr.new(Fabulator::XSM::RootContext.new, [], val[1]) }
    | SLASH_SLASH relative_location_path { result = [ Fabulator::XSM::RootContext.new, Fabulator::XSM::AxisDescendentOrSelf.new(val[1][0]) ] + val[1][1..val[1].size-1] }
    | axis_name SLASH relative_location_path { result = [ Fabulator::XSM::RootContext.new(val[0]) ] + val[2] }
    | axis_name SLASH_SLASH relative_location_path { result = [ Fabulator::XSM::RootContext.new(val[0]), Fabulator::XSM::AxisDescendentOrSelf.new(val[2][0]) ] + val[2][1..val[2].size-1] }

  relative_location_path: step { result = [ val[0] ] }
    | relative_location_path SLASH step { result = val[0] + [ val[2] ] }
    | relative_location_path SLASH_SLASH step { result = val[0] + [ Fabulator::XSM::AxisDescendentOrSelf.new(val[2]) ] }

  step: axis node_test predicates { result = Fabulator::XSM::Predicates.new(Fabulator::XSM::Step.new(val[0], val[1]), val[2]) }
    #| axis LC DOLLAR_QNAME RC predicates { result = Fabulator::XSM::Predicates.new(Fabulator::XSM::Step.new(val[0], Fabulator::XSM::QName.new(val[3])), val[4]) }
    | AXIS_METHOD COLON_COLON node_test predicates { result = Fabulator::XSM::Predicates.new(Fabulator::XSM::Function.new(@namespaces, val[2], []), val[3]) }
    | AXIS_METHOD COLON_COLON FUNCTION_NAME LP opt_args RP predicates { result = Fabulator::XSM::Predicates.new(Fabulator::XSM::Function.new(@namespaces, val[2], val[4]), val[6]) }
    | DOT { result = Fabulator::XSM::CurrentContext.new }
    | DOT_DOT { result = Fabulator::XSM::AncestorContext.new }

  axis:
    | axis_name
    | AT { result = Fabulator::XSM::Axis.new('attribute')  }

  axis_name: AXIS_NAME COLON_COLON { result = Fabulator::XSM::Axis.new(val[0]) }

  predicates: { result = [ ] }
    | predicates LB expr RB { result = val[0] + [ val[2] ] }

    #| '<' expr '>'
  primary_expr:
    DOLLAR_QNAME { result = Fabulator::XSM::Var.new(val[0]) }
    | LP expr RP { result = val[1] }
    | LITERAL { result = Fabulator::XSM::Literal.new(val[0]) }
    | NUMBER { result = Fabulator::XSM::Literal.new(val[0]) }
    | FUNCTION_NAME LP opt_args RP { result = Fabulator::XSM::Function.new(@namespaces, val[0], val[2]) }

  opt_args: { result = [ ] }
    | args 

  args: expr { result = [ val[0] ] }
    | args COMMA expr { result = val[0] + [ val[2] ] }

  node_test: QNAME
    | LC expr RC { result = val[1] }
    | STAR

end

---- inner 
  require 'fabulator/xsm'

  def parse(t, xml = { })
    @source = t
    @curpos = 0
    @namespaces = { }

    if xml.nil?
      @namespaces = { }
    elsif xml.is_a?(Hash)
      @namespaces = xml
    else
      xml.namespaces.each do |ns|
        @namespaces[ns.prefix] = ns.href
      end
      begin
        @namespaces[''] = xml.namespaces.default.href
      rescue
      end
    end

    @yydebug = true

    @last_token = nil
      
    do_parse
  end

  @@regex = {
    :simple_tokens => %r{\.\.|::|!=|>=|<=|\/\/|:=|\.|@|[*]|\(|\)|\[|\]|\{|\}|\/|\||\+|-|=|>|<|&|,|;},
    :ncname => %r{(?:[a-zA-Z_][-a-zA-Z0-9_.]*)},
    :event_type => %r{(?:processing-instruction|comment|text|node)},
    :axis_name => %r{(?:attribute|child|child-or-self|descendant|descendant-or-self|method|self)},
    :namespace_name => %r{(?:context|global|local|session|universal)},
    :number => %r{(-?\d+(?:\.\d+)?|\.\d+)},
  }

  @@regex[:axis] = %r{(#{@@regex[:ncname]})\s*(?=::)}
  @@regex[:name_colon_star] = %r{(#{@@regex[:ncname]}:\*)}
  @@regex[:qname] = %r{((?:#{@@regex[:ncname]}:)?#{@@regex[:ncname]})}
  @@regex[:dollar_qname] = %r{\$#{@@regex[:qname]}}
  @@regex[:function_name] = %r{#{@@regex[:qname]}\s*(?=\([^:])}

  @@ops = {
    '..' => :DOT_DOT,
    '::' => :COLON_COLON,
    '!=' => :NEQ,
    '>=' => :GTE,
    '<=' => :LTE,
    '//' => :SLASH_SLASH,
    ':=' => :COLON_EQUAL,
    '.'  => :DOT,
    '@'  => :AT,
    '*'  => :STAR,
    '('  => :LP,
    ')'  => :RP,
    '['  => :LB,
    ']'  => :RB,
    '{'  => :LC,
    '}'  => :RC,
    '/'  => :SLASH,
    '|'  => :PIPE,
    '+'  => :PLUS,
    '-'  => :MINUS,
    '='  => :EQ,
    '>'  => :GT,
    '<'  => :LT,
    '&'  => :AMP,
    ','  => :COMMA,
    ';'  => :SEMI
  }

  @@preceding_tokens = { }
  [%{
    @ :: ( 
    and or mod div 
    * 
    / // | + - = != < <= > >=
    == & && ||
  }.split(/\s*/), '[', ',', '$' ].each { |t| @@preceding_tokens[t] = true }

  @@regex[:general] = Regexp.compile(%{^(?:#{@@regex[:function_name]}|#{@@regex[:axis]}|#{@@regex[:name_colon_star]}|#{@@regex[:qname]}|('[^']*'|"[^"]*")|#{@@regex[:number]}|#{@@regex[:dollar_qname]}|(#{@@regex[:simple_tokens]}))})

  def next_token  
    @token = nil
    white_space = 0
    new_line = 0
    while @curpos < @source.length && @source[@curpos..@curpos] =~ /\s/ do
      if @source[@curpos..@curpos] =~ /\n/
        new_line = new_line + 1
      end
      @curpos = @curpos + 1
      white_space = white_space + 1
    end

    # skip comments delimited by (:  :)
    # comments can be nested
    # these are XPath 2.0 comments
    #
    if @curpos < @source.length && @source[@curpos..@curpos+1] == '(:'
      comment_depth = 1
      @curpos = @curpos + 2
      while comment_depth > 0 && @curpos < @source.length
        if @source[@curpos..@curpos+1] == '(:'
          comment_depth = comment_depth + 1
          @curpos = @curpos + 1
        end
        if @source[@curpos..@curpos+1] == ':)'
          comment_depth = comment_depth - 1
          @curpos = @curpos + 1
        end
        @curpos = @curpos + 1
      end
      white_space = white_space + 1
    end

    while @curpos < @source.length && @source[@curpos..@curpos] =~ /\s/ do
      if @source[@curpos..@curpos] =~ /\n/
        new_line = new_line + 1
      end
      @curpos = @curpos + 1
      white_space = white_space + 1
    end
        
    if @curpos >= @source.length
      @last_token = nil
      return [ false, false ]
    end

    #if new_line > 0 || white_space > 0
    #  @token = [ :SP, '' ]
    #end

    if @token.nil? && @last_token && ! @@preceding_tokens[@last_token[1]]
      #Rails.logger.info("last token: <#{@last_token[0]}|#{@last_token[1]}>")
      #Rails.logger.info("preceding_tokens: #{@@preceding_tokens[@last_token[1]] ? 'true' : 'false'}")
      if @source[@curpos..@curpos] == '*'
        @token = [ :STAR, '*' ]
      else
        if @source[@curpos..@source.length-1] =~ /^(#{@@regex[:ncname]})/
          ncname = $1
          case ncname
            when 'for':
              @token = [ :FOR, 'for' ]
            when 'return':
              @token = [ :RETURN, 'return' ]
            when 'in':
              @token = [ :IN, 'in' ]
            when 'let':
              @token = [ :LET, 'let' ]
            when 'except':
              @token = [ :EXCEPT, 'except' ]
            when 'every':
              @token = [ :EVERY, 'every' ]
            when 'some':
              @token = [ :SOME, 'some' ]
            when 'satisfies':
              @token = [ :SATISFIES, 'satisfies' ]
            when 'if':
              @token = [ :IF, 'if' ]
            when 'then':
              @token = [ :THEN, 'then' ]
            when 'else':
              @token = [ :ELSE, 'else' ]
            when 'to':
              @token = [ :TO, 'to' ]
            when 'and':
              @token = [ :AND, 'and' ]
            when 'or':
              @token = [ :OR, 'or' ]
            when 'mod':
              @token = [ :MOD, 'mod' ]
            when 'div':
              @token = [ :DIV, 'div' ]
            #when '*doh*':
            #  # do nothing
            #  @token = nil
            else
              @token = nil
          end
        end
      end
    end
 
    if @token.nil? && @source[@curpos..@curpos+1] == '..'
      @token = [ :DOT_DOT, '..' ]
    end

    if @token.nil?
      if @curpos >= @source.length
        @token = [false, false]
        return @token
      end

      res = @@regex[:general].match(@source[@curpos..@source.length-1])
      #@source[@curpos..@source.length-1] =~ @@regex[:general]
      #res = [ nil, $1, $2, $3, $4, $5, $6, $7, $8 ]
      if res.nil?
        raise "Failed to parse '#{@source}' at #{@curpos}': #{@source[@curpos..@source.length-1]}"
      else
        if !res[1].nil?
          if res[1] == 'if'
            @token = [ :IF, 'if' ]
          else
            @token = [ :FUNCTION_NAME, res[1] ]
          end
        elsif !res[2].nil?
          @token = [ res[2] == 'method' ? :AXIS_METHOD : :AXIS_NAME, res[2] ]
        elsif !res[3].nil?
          @token = [ :NAME_COLON_STAR, res[3] ]
        elsif !res[4].nil?
          qname = res[4]
          case qname
            when 'for':
              @token = [ :FOR, 'for' ]
            when 'return':
              @token = [ :RETURN, 'return' ]
            when 'in':
              @token = [ :IN, 'in' ]
            when 'let':
              @token = [ :LET, 'let' ]
            when 'except':
              @token = [ :EXCEPT, 'except' ]
            when 'every':
              @token = [ :EVERY, 'every' ]
            when 'some':
              @token = [ :SOME, 'some' ]   
            when 'satisfies':
              @token = [ :SATISFIES, 'satisfies' ]
            when 'if':
              @token = [ :IF, 'if' ]
            when 'then':
              @token = [ :THEN, 'then' ]
            when 'else':
              @token = [ :ELSE, 'else' ]
            else
              @token = [ :QNAME, res[4] ]
          end
        elsif !res[5].nil?
          s = res[5]
          s = s[1..s.length-2]
          @token = [ :LITERAL, s ]
          @curpos = @curpos + 2  # the quotes
        elsif !res[6].nil?
          @token = [ :NUMBER, res[6] ]
        elsif !res[7].nil?
          @curpos = @curpos + 1
          @token = [ :DOLLAR_QNAME, res[7] ]
        elsif !res[8].nil?
          Rails.logger.info("op: #{res[8]} => #{@@ops[res[8]]}")
          @token = [ @@ops[res[8]] || res[8], res[8] ]
        else
          raise "Failed to parse '#{@source}' at #{@curpos}: #{@source[@curpos..@source.length-1]}"
        end
      end
    end

    Rails.logger.info("Token: [#{@token[0].to_s},#{@token[1].to_s}]")
    if !@token[1].nil?
      @curpos = @curpos + @token[1].length
    end
    @last_token = @token
    return @token
  end
