class Fabulator::XSM::ExpressionParser
  # based on XSM expression grammer from 
  #    http://cpansearch.perl.org/src/JSMITH/Gestinanna-0.02/parser.PL

  # instead of compiling ruby code, we'll instantiate objects to handle the
  # run-time performance

  start statements

rule
  statements: statement { result = Fabulator::XSM::StatementList.new; result.add_statement(val[0]) }
    | statements req_sp statement { result = val[0]; result.add_statement(val[2]) }

  statement: expr
    | let_expr

  expr: or_expr
    | range_expr
    | if_expr
    | for_expr
    | quant_expr

  sp:
    | req_sp

  req_sp: SP
    | NL

  let_expr: LET req_sp DOLLAR_QNAME sp ':=' sp expr { result = Fabulator::XSM::LetExpr(val[2], val[6]) }
  

  if_expr: IF sp '(' sp expr sp ')' sp THEN sp expr sp ELSE sp expr { result = Fabulator::XSM::IfExpr.new(val[4], val[10], val[14]) }
    | IF sp '(' sp expr sp ')' sp THEN sp expr { result = Fabulator::XSM::IfExpr.new(val[4], val[10], nil) }

  for_expr: FOR req_sp for_vars req_sp RETURN req_sp expr { result = Fabulator::XSM::ForExpr.new(val[2], val[6]) }

  for_vars: for_var { result = [ val[0] ] }
    | for_vars sp COMMA sp for_var { result = val[0] + [ val[4] ] }

  for_var: DOLLAR_QNAME req_sp IN req_sp expr { result = Fabulator::XSM::ForVar.new(val[0], val[4]) }

  quant_expr: SOME req_sp for_vars req_sp SATISFIES req_sp expr { result = Fabulator::XSM::SomeExpr(val[2], val[6]) }
    | EVERY req_sp for_vars req_sp SATISFIES req_sp expr { result = Fabulator::XSM::EveryExpr(val[2], val[6]) }

  or_expr: and_expr
    | or_expr req_sp OR req_sp and_expr { result = Fabulator::XSM::OrExpr.new(val[0], val[4]) }

  and_expr: equality_expr
    | and_expr req_sp AND req_sp equality_expr { result = Fabulator::XSM::AndExpr.new(val[0], val[4]) }
    | and_expr req_sp EXCEPT req_sp equality_expr { result = Fabulator::XSM::ExceptExpr.new(val[0], val[4]) }

  equality_expr: relational_expr
    | equality_expr sp '=' sp relational_expr { result = Fabulator::XSM::EqExpr.new(val[0], val[4]) }
    | equality_expr sp '!=' sp relational_expr { result = Fabulator::XSM::NeqExpr.new(val[0], val[4]) }

  relational_expr: additive_expr
    | relational_expr sp '<' sp additive_expr { result = Fabulator::XSM::LtExpr.new(val[0], val[4]) }
    | relational_expr sp '>' sp additive_expr { result = Fabulator::XSM::LtExpr.new(val[4], val[0]) }
    | relational_expr sp '<=' sp additive_expr { result = Fabulator::XSM::LteExpr.new(val[0], val[4]) }
    | relational_expr sp '>=' sp additive_expr { result = Fabulator::XSM::LteExpr.new(val[4], val[0]) }

  range_expr: additive_expr sp '..' sp additive_expr { result = Fabulator::XSM::RangeExpr.new(val[0], val[4]) }
    | additive_expr req_sp TO req_sp additive_expr { result = Fabulator::XSM::RangeExpr.new(val[0], val[4]) }

  additive_expr: multiplicative_expr
    | additive_expr sp '+' sp multiplicative_expr { result = Fabulator::XSM::AddExpr.new(val[0], val[4]) }
    | additive_expr sp '-' sp multiplicative_expr { result = Fabulator::XSM::SubExpr.new(val[0], val[4]) }

  multiplicative_expr: unary_expr
    | multiplicative_expr sp '*' sp unary_expr { result = Fabulator::XSM::MpyExpr.new(val[0], val[4]) }
    | multiplicative_expr req_sp DIV req_sp unary_expr { result = Fabulator::XSM::DivExpr.new(val[0], val[4]) }
    | multiplicative_expr req_sp MOD req_sp unary_expr { result = Fabulator::XSM::ModExpr.new(val[0], val[4]) }

  unary_expr: union_expr
    | '-' sp unary_expr { result = Fabulator::XSM::NegExpr.new(val[2]) }

  union_expr: path_expr
    | union_expr_x { result = Fabulator::XSM::UnionExpr.new(val[0]) }

  union_expr_x: path_expr sp '|' sp path_expr { result = [ val[0], val[4] ] }
    | union_expr_x sp '|' sp path_expr { result = val[0] + [ val[4] ] }

  path_expr: location_path { result = Fabulator::XSM::PathExpr.new(nil, [], val[0]) }
    | primary_expr predicates segment { result = Fabulator::XSM::PathExpr.new(val[0], val[1], val[2]) }

  segment:
    | '/' relative_location_path { result = val[1] }
    | '//' relative_location_path { result = [ Fabulator::XSM::AxisDescendentOrSelf.new ] + val[1] }

  location_path: relative_location_path 
    | absolute_location_path

  # / => local data root
  # // => local data descendent or self

  absolute_location_path: '/' { result = Fabulator::XSM::RootContext.new }
    | '/' relative_location_path { result = Fabulator::XSM::PathExpr.new(Fabulator::XSM::RootContext.new, [], val[1]) }
    | '//' relative_location_path { result = [ Fabulator::XSM::RootContext.new, Fabulator::XSM::AxisDescendentOrSelf.new(val[1][0]) ] + val[1][1..val[1].size-1] }
    | AXIS_NAME '::' '/' relative_location_path { result = [ Fabulator::XSM::RootContext.new(val[0]) ] + val[3] }
    | AXIS_NAME '::' '//' relative_location_path { result = [ Fabulator::XSM::RootContext.new(val[0]), Fabulator::XSM::AxisDescendentOrSelf.new(val[3][0]) ] + val[3][1..val[3].size-1] }

  relative_location_path: step { result = [ val[0] ] }
    | relative_location_path '/' step { result = val[0] + [ val[2] ] }
    | relative_location_path '//' step { result = val[0] + [ Fabulator::XSM::AxisDescendentOrSelf.new(val[2]) ] }

  step: axis node_test predicates { result = Fabulator::XSM::Predicates.new(Fabulator::XSM::Step.new(val[0], val[1]), val[2]) }
    #| axis '{' sp DOLLAR_QNAME sp '}' predicates { result = Fabulator::XSM::Predicates.new(Fabulator::XSM::Step.new(val[0], Fabulator::XSM::QName.new(val[3])), val[4]) }
    | AXIS_METHOD '::' node_test predicates { result = Fabulator::XSM::Predicates.new(Fabulator::XSM::Function.new(@namespaces, val[2], []), val[3]) }
    | AXIS_METHOD '::' FUNCTION_NAME '(' sp opt_args sp ')' predicates { result = Fabulator::XSM::Predicates.new(Fabulator::XSM::Function.new(@namespaces, val[2], val[5]), val[8]) }
    | '.' { result = Fabulator::XSM::CurrentContext.new }
    | '..' { result = Fabulator::XSM::AncestorContext.new }

  axis:
    | AXIS_NAME '::' { result = Fabulator::XSM::Axis.new(val[0]) }
    | '@' { result = Fabulator::XSM::Axis.new('attribute')  }

  predicates: { result = [ ] }
    | predicates '[' sp expr sp ']' { result = val[0] + [ val[3] ] }

    #| '<' expr '>'
  primary_expr:
    DOLLAR_QNAME { result = Fabulator::XSM::Var.new(val[0]) }
    | '(' sp expr sp ')' { result = val[2] }
    | LITERAL { result = Fabulator::XSM::Literal.new(val[0]) }
    | NUMBER { result = Fabulator::XSM::Literal.new(val[0]) }
    | FUNCTION_NAME '(' sp opt_args sp ')' { result = Fabulator::XSM::Function.new(@namespaces, val[0], val[3]) }

  opt_args: { result = [ ] }
    | args 

  args: expr { result = [ val[0] ] }
    | args sp ',' sp expr { result = val[0] + [ val[4] ] }

  node_test: QNAME
    | '{' sp expr sp '}' { result = val[2] }
    | '*'

end

---- inner 
  require 'fabulator/xsm'

  def parse(t, xml = { })
    @source = t
    @curpos = 0
    @namespaces = { }

    if xml.nil?
      @namespaces = { }
    elsif xml.is_a?(Hash)
      @namespaces = xml
    else
      xml.namespaces.each do |ns|
        @namespaces[ns.prefix] = ns.href
      end
      begin
        @namespaces[''] = xml.namespaces.default.href
      rescue
      end
    end

    @yydebug = true

    @last_token = nil
      
    do_parse
  end

  @@regex = {
    :simple_tokens => %r{\.\.|::|!=|>=|<=|==|\|\||&&|\/\/|:=|\.|@|\*|\(|\)|\[|\]|\{|\}|\/|\||\+|-|=|>|<|&|,|;},
    :ncname => %r{(?:[a-zA-Z_][a-zA-Z0-9_.-]*)},
    :event_type => %r{(?:processing-instruction|comment|text|node)},
    :axis_name => %r{(?:attribute|child|child-or-self|descendant|descendant-or-self|method|self)},
    :namespace_name => %r{(?:context|global|local|session|universal)},
    :number => %r{(-?\d+(?:\.\d+)?|\.\d+)},
  }

  @@regex[:axis] = %r{(#{@@regex[:ncname]})\s*(?=::)}
  @@regex[:name_colon_star] = %r{(#{@@regex[:ncname]}:\*)}
  @@regex[:qname] = %r{((?:#{@@regex[:ncname]}:)?#{@@regex[:ncname]})}
  @@regex[:dollar_qname] = %r{\$#{@@regex[:qname]}}
  @@regex[:function_name] = %r{#{@@regex[:qname]}\s*(?=\([^:])}

  @@preceding_tokens = { }
  [%{
    @ :: ( 
    and or mod div 
    * 
    / // | + - = != < <= > >=
    == & && ||
  }.split(/\s*/), '[', ',', '$' ].each { |t| @@preceding_tokens[t] = true }

  @@regex[:general] = Regexp.compile(%{^(?:#{@@regex[:function_name]}|#{@@regex[:axis]}|#{@@regex[:name_colon_star]}|#{@@regex[:qname]}|('[^']*'|"[^"]*")|#{@@regex[:number]}|#{@@regex[:dollar_qname]}|(#{@@regex[:simple_tokens]}))})

  def next_token  
    @token = nil
    white_space = 0
    new_line = 0
    while @curpos < @source.length && @source[@curpos..@curpos] =~ /\s/ do
      if @source[@curpos..@curpos] =~ /\n/
        new_line = new_line + 1
      end
      @curpos = @curpos + 1
      white_space = white_space + 1
    end

    # skip comments delimited by (:  :)
    # comments can be nested
    # these are XPath 2.0 comments
    #
    if @curpos < @source.length && @source[@curpos..@curpos+1] == '(:'
      comment_depth = 1
      @curpos = @curpos + 2
      while comment_depth > 0 && @curpos < @source.length
        if @source[@curpos..@curpos+1] == '(:'
          comment_depth = comment_depth + 1
          @curpos = @curpos + 1
        end
        if @source[@curpos..@curpos+1] == ':)'
          comment_depth = comment_depth - 1
          @curpos = @curpos + 1
        end
        @curpos = @curpos + 1
      end
      white_space = white_space + 1
    end

    while @curpos < @source.length && @source[@curpos..@curpos] =~ /\s/ do
      if @source[@curpos..@curpos] =~ /\n/
        new_line = new_line + 1
      end
      @curpos = @curpos + 1
      white_space = white_space + 1
    end
        
    if @curpos >= @source.length
      @last_token = nil
      return [ false, false ]
    end

    if new_line > 0
      @token = [ :NL, new_line ]
    elsif white_space > 0
      @token = [ :SP, white_space ]
    end

    if @token.nil? && @last_token && ! @@preceding_tokens[@last_token[1]]
      if @source[@curpos..@curpos] == '*'
        @token = [ '*', '*' ]
      else
        if @source[@curpos..@source.length-1] =~ /^(#{@@regex[:ncname]})/
          ncname = $1
          case ncname
            when 'let':
              @token = [ :LET, 'let' ]
            when 'except':
              @token = [ :EXCEPT, 'except' ]
            when 'every':
              @token = [ :EVERY, 'every' ]
            when 'some':
              @token = [ :SOME, 'some' ]
            when 'satisfies':
              @token = [ :SATISFIES, 'satisfies' ]
            when 'if':
              @token = [ :IF, 'if' ]
            when 'then':
              @token = [ :THEN, 'then' ]
            when 'else':
              @token = [ :ELSE, 'else' ]
            when 'to':
              @token = [ :TO, 'to' ]
            when 'and':
              @token = [ :AND, 'and' ]
            when 'or':
              @token = [ :OR, 'or' ]
            when 'mod':
              @token = [ :MOD, 'mod' ]
            when 'div':
              @token = [ :DIV, 'div' ]
            #when '*doh*':
            #  # do nothing
            #  @token = nil
            else
              @token = [ :QNAME, ncname ]
          end
        end
      end
    end
 
    if @token.nil? && @source[@curpos..@curpos+1] == '..'
      @token = [ :RANGE, '..' ]
    end

    if @token.nil?
      res = @@regex[:general].match(@source[@curpos..@source.length-1])
      #@source[@curpos..@source.length-1] =~ @@regex[:general]
      #res = [ nil, $1, $2, $3, $4, $5, $6, $7, $8 ]
      if !res[1].nil?
        @token = [ :FUNCTION_NAME, res[1] ]
      elsif !res[2].nil?
        @token = [ res[2] == 'method' ? :AXIS_METHOD : :AXIS_NAME, res[2] ]
      elsif !res[3].nil?
        @token = [ :NAME_COLON_STAR, res[3] ]
      elsif !res[4].nil?
        @token = [ :QNAME, res[4] ]
      elsif !res[5].nil?
        s = res[5]
        s = s[1..s.length-2]
        @token = [ :LITERAL, s ]
      elsif !res[6].nil?
        @token = [ :NUMBER, res[6] ]
      elsif !res[7].nil?
        @token = [ :DOLLAR_QNAME, res[7] ]
      elsif !res[8].nil?
        @token = [ res[8], res[8] ]
      else
        raise "Failed to parse '#{@source}' at #{@curpos}"
      end
    end

    if !@token[1].nil?
      @curpos = @curpos + @token[1].length
    end
    @last_token = @token
    Rails.logger.info("Token: [#{@token[0].to_s},#{@token[1].to_s}]")
    return @token
  end
